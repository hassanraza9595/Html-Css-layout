<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavascriptMastery</title>
</head>

<body>
    <script>

        // *************************************************************************************************    

        // Conditional logic with if statements, the ternary operator, and logical operators

        // const name = "Hassan";

        //  const student = name === "Hassan" ? 'Belong TO IT' : 'None'; // if condition tru return 'Belong to IT' and assign student otherwise return else.

        //  console.log(student);



        //  if(name === "Hassan") {
        //      const student = name;
        //      console.log(student);
        //  }
        //  else {
        //      const student = 'None';
        //      console.log(student);
        //  }

        // **************************************************************************************************

        // logical Operator  And && or ||

        // const play = true;

        // cricket = team => team ;

        // const Team = play && cricket(46);

        // console.log(Team);

        // It is also possible to combine multiple conditions.

        // const student = true;
        // const name = 'Hassan';

        // const studentID = student && name?.length  > 5 && name;
        // console.log(studentID);

        // *************************************************************************************************

        // Object literals and inline functions

        // const student = { name: 'hassan', rollNo: 46, batch: '2K18'};


        // 2nd function argument uses inline object literal
        // student("name", { batch: "2K18" })

        // With ES2015 syntax, you can also use shorthand properties and method names.


        // instead of 
        // function student(id) {
        //     return {
        //         name: 'hassan',
        //         id : id,
        //         study: function() {
        //             console.log('PIAIC');
        //         }
        //     }
        // }

        // console.log(student(46));

        // var getFun = student(46)

        // getFun.study();

        // You can

        // function foo(name,id) {
        //   return {
        //     name,
        //     id, // shorthand property name
        //     bar() { // shorthand method name
        //       console.log("bar");
        //     }
        //   }
        // }

        // var getFun2 = foo('hassan',46);
        // console.log(getFun2);


        // ****************************************************************************************************

        // Template literals or stings

        // const name = 'hassan';
        // const insititute = prompt('Enter Insititute: ');

        // console.log(`This is ${name}, Student of ${insititute}`);

        // console.log(Math.floor(Math.random() * Math.floor(5)));

        // Expressions can, of course, be more complex, like inline calculations or function calls.

        //         const name = "doppelmutzi";
        //         const getRandomIndex = max => Math.floor(Math.random() * Math.floor(max))
        //         const food = ["🥞", "🧇", "🍔", "🍟", "🍕"];
        //         const getFood = index => food[index]
        //         console.log(`Hello, my name is ${name} 
        // and I'm hungry for ${getFood(getRandomIndex(food.length))}`);

        // console.log(Math.random()*5)

        // ************************************************************************************************************

        //  Object Destructuring

        //  extract properties into variables.

        // const students = {
        //     stud: ['hassan', 46, '2K18', 'IT'],
        //     stud2:  ['hassan raza', 36, '2K18', 'IT'],
        //         }

        // const {stud, stud2} = students; // Good Approach to follow

        // console.log(stud);
        // console.log(stud2);

        // If you use assignment without variable declaration, you need to use parentheses.

        // let stud, stud2; // ['hassan', 46, '2K18', 'IT']
        // ({stud, stud2} = students); //  ['hassan raza', 36, '2K18', 'IT']

        // console.log(stud);
        // console.log(stud2); 

        // Object destructuring offers you syntactical sugar to save extra lines of code.

        // const stud = students.stud;
        // const stud2 = students.stud2;

        // console.log(stud);
        // console.log(stud2); 

        //  In the context of React, object destructuring is frequently used with function parameters. (IMP)

        //  const student = {name:'hassan', hobby:'React'};

        //  function show({hobby, name}) {
        //      console.log(name, hobby)
        //  }
        //  show(student);

        //  printName = ({name}) => {
        //      console.log(name);
        //  }


        //  printName(student);


        // Assigning in combination with renaming variables might be useful to increase the readability of your code.

        //  const course = {
        //      subjects: ['java', 'python', 'react', 'html', 'css']
        //  }

        //  const {subjects : latest} = course;
        //  console.log(latest)


        // You can also define default values while unpacking fields from the assigned object.
        // The following example combines multiple techniques.


        // const {
        //     numbers : odd = [1,3], 
        //     numbers2:even = [2,4] } 

        //     = {
        //         numbers: [1,2,3,4],
        //         numbers2:[5,6,7,8]
        //     };

        //     console.log(odd);
        //     console.log(even);


        // Nesting is also possible, but I wouldn’t recommend overdoing it; otherwise, understandability decreases.

        // const creatures = {
        //   animals: {
        //     wildlife: ["🦂", "🐍"],
        //     pet: ["🐕", "🐈"]

        // },
        //   human: ["👨🏿‍💼", "👩🏼‍💼", "🧑🏻‍💼"]
        // };
        // const { human, animals:{wildlife,pet} } = creatures;
        // console.log(wildlife); //  ["🐕", "🐈"]
        // console.log(pet);
        // console.log(human);

        //***********************************************************************************************************

        // Array Destructuring 

        // With the help of the destructuring assignment, 
        // an array can be unpacked in such a way that its values are extracted into distinct variables, like this:                            


        // const names = ['Ali','Hassan','Yousif','Kamran','Yasir','Iftikhar','Atif']; //  skip values under consideration of the order.

        // const [name,,name2,,,name3,name4] = names; // 0 index value assign to name, 1 to name2, so on.

        // console.log(name);
        // console.log(name2);
        // console.log(name3);
        // console.log(name4);

        // You can also assign multiple values at once with the rest pattern.

        // const numbers = [1,2,3,4,5,6];

        // const [num, num2, ...num3] = numbers

        // console.log(num);
        // console.log(num2);
        // console.log(num3);

        // Array destructuring allows for default values. Of course, you can combine this pattern with function calls, too.


        // const addFun = () => [10,20,30,40,50];

        // const [n1, n2, n3 = 60] = addFun();
        // console.log(n1);
        // console.log(n2);
        // console.log(n3) 

        // Array destructuring allows the function caller to use semantic variable names.

        // const getFood = type => {
        //     let food = [];
        //     let error = false;
        //     if(type==='fruit'){
        //         food = ['Apple', 'Banana', 'Strawberry'];
        //     }
        //     else if(type === 'junk') {

        //         food = ['pizza', 'burger', 'chicken tika'];
        //     }

        //     else {
        //         error = true;
        //     }

        //     const addFood = newFood => food.push(newFood);
        //     return [food, error, addFood]; // food is array, error is variable, addFood is function

        // };

        // const [healtyFood, noFruitsAvailable, addFruitFunc] = getFood('fruit');
        // console.log(healtyFood); // healtyFood is function 
        // console.log(noFruitsAvailable); // noFruitsAvailable is a variable
        // console.log(addFruitFunc('Mango')); // addFruitFunc is a function
        // console.log(healtyFood);




        /*
        For this use case, in my opinion, returning an array with the getFood function leads
         to more concise code than with object destructuring.
         Array destructuring allows for custom variable names.
         In contrast, with object destructuring, you need to rename the variables.
        */



        // const getFood = type => {
        //     let food = [];
        //     let error = false;
        //     if(type==='fruit'){
        //         food = ['Apple', 'Banana', 'Strawberry'];
        //     }
        //     else if(type === 'junk') {

        //         food = ['pizza', 'burger', 'chicken tika'];
        //     }

        //     else {
        //         error = true;
        //     }

        //     const addFood = newFood => food.push(newFood);
        //     return {food, error, addFood}; // food is array, error is variable, addFood is function

        // };


        //    const {food: healtyFood, error: noFruitsAvailable, addFood: addFruitFunc} = getFood('fruit');

        //    console.log(noFruitsAvailable);
        //    console.log(addFruitFunc('Grapes'));
        //    console.log(healtyFood);

        // *********************************************************************************************************   

        // Spread operator

        //The spread operator (...) allows an iterable item (e.g., an array)
        // to be extracted into its parts and plugged into places that
        // expect individual elements. With this syntax, you can split up object properties or array elements.

        /* In the next use case below, we pull out elements of an array
         and pass each element as individual function argument. */

        //  const numbers = [11, 5, 3, 1, 26];
        // Math.max expects to be called like Math.max(11,5,3,1,26)
        // console.log(Math.max(...numbers)); // 26

        // Another use case is to copy object properties and, thus, create a new object.

        // const food = {
        //     breakfast: ["🥞", "🧇"],
        //     lunch: ["🍔", "🍟", "🍕"]
        // };
        // const foodAndDrinks = {
        //     ...food,
        //     drinks: ["🍷", "🍹", "🍺", "🥃"],
        // };
        // console.log(foodAndDrinks);
        /*
                {
                  breakfast: ["🥞", "🧇"],
                  lunch: ["🍔", "🍟", "🍕"],
                  drinks: ["🍷", "🍹", "🍺", "🥃"],
                } */

        // Another use case is to copy object properties and, thus, create a new object.

        //    const teams = {
        //        australia: {
        //            players: ['Warner', 'Watson', 'Hussey', 'Smith']
        //        },
        //        india: {
        //            players: ['Dhawan', 'Rohit', 'Kohli', 'Rahul']
        //        }
        //    };

        //   const teams2 = {
        //       ...teams,
        //       team:['Pakistan', 'Newzi'],
        //   };

        //   console.log(teams2.india);

        // With this succinct(short) syntax, you can conveniently create a copy of an array.

        // const food = ["🥞", "🧇", "🍔", "🍟", "🍕"];
        // const copy = [...food];
        //  const copy = food;
        // console.log(typeof copy); // ["🥞", "🧇", "🍔", "🍟", "🍕"]
        // console.log(typeof food);
        // console.log(food === copy); // false


        /* Recalling the last paragraph of our subsection on the switch statement,
        the spread syntax is frequently used in the context of React state.
        With React, you should not manipulate state objects directly.
        Instead, you need to create a brand-new state object whenever you want to update the state.
        The following concept is considered good practice. */


        // const family = {
        //     members: 9,
        //     membersName: ['Ali', 'Hassan', 'etc'],
        // }

        // const belongsTo = {
        //     gaji: [...family.membersName],
        //     Total: family.members,
        // }

        // console.log(belongsTo.gaji)
        // console.log(belongsTo.Total);

        // **********************************************************************************************************

        // Rest operator

        // With the help of the rest operator (...), you can merge a list of function arguments into an array.    

        // Its purpose is to merge a list of values into an array.

        //  const family = (...names) => names ;

        //  var check = family('ali', 'raza', 'fiza');
        //  console.log(check);          

        /* It is a common practice to use the rest operator in combination with the spread operator.
         This combines multiple arguments into an array to distribute the entries again in
         another place inside of a React component. */

        // function renderProduct(
        //     // these are considered as component-specific
        //     { id, name },
        //     /* all other arguments are relevant for container component. Therefore, consolidate them into an array with rest operator */
        //     ...containerProps) {
        //     // output 0815, choco, [{margin: "10px"}, {padding: "5px"}]
        //     console.log(id, name, containerProps);
        //     console.log(typeof id); // string 
        //     console.log(typeof name); //string
        //     console.log(typeof containerProps); // object
        //     /* unpack array again with spread operator to provide them as individual args */
        //     renderContainer(...containerProps);


        // }
        // function renderContainer(margin, padding) {
        //     // output {margin: "10px"}, {padding: "5px"}
        //     console.log('Render Container')
        //     console.log(typeof margin);
        //     console.log(typeof padding)
        //     console.log(margin, padding);
        // }
        // const product = {
        //     id: "0815", name: "choco"
        // }
        // renderProduct(product, { margin: "10px" }, { padding: "5px" });

// ************************************************************************************************************

                          // Classes

/*

A class represents a blueprint for new objects.
Variables and functions can be attached to a class and are called properties and methods, respectively.
In the context of a class, the this keyword refers to the current instance.
If you are coming from an object-oriented background,
you most likely have some incorrect assumptions about it; this article helps to demystify the this keyword.

A class can have a constructor method, which represents a special kind of function
to initialize new objects of the blueprint.
You can instantiate the class with the new keyword.
With this, the constructor is invoked (or the default constructor,
if you do not provide any), and a new object is created.

  */

//   class Leader {
//       // class body
//       constructor() {
//           // property
//           this.popular = "Zia Khan";
//           console.log('Constructor called once the object created');
//       }

//       whatsPopular() {
//           // method body
//           console.log(this.popular);
//       }
//   };

//   const teacher = new Leader(); 
//   teacher.whatsPopular();

// ***************************************************************************************************

//                      Array functions


/* The map() function produces a new array with the same number of elements.
 However, for every entry of the original entry, an operation was applied to produce new entries.
 The following example creates a new array with duplicated fruits for every entry. */

//  const numbers = [1,2,3,4,5];

//  const copyNumbers = numbers.map(f=>`${f}${f}`);
//  console.log(numbers);
//  console.log(typeof copyNumbers[0]);

// ****************************************************************************************************

                                    // Callback functions

// A function passed as an argument to another function is 
// called a callback if the function invokes the argument at a later time.    

// window.setTimeout(() => console.log("I'm a callback function"), 1000);

function printGreet(msg, alertGreet) {
    if(msg === 'Morning') {
     morning(alertGreet);
}
else if (msg === 'Evening') {
    evening(alertGreet);
}
else {
    night(alertGreet);
}
};

function morning() {
    alert('Good Morning');
    alertGreet('Dear');
}

function evening() {
    alert('Good Evening');
    alertGreet('Bye');
}

function night() {
    alert('Good Night');
    alertGreet('Take Care');
}

function alertGreet(msg) {
    alert(msg);
}

printGreet('Evening', alertGreet);


    </script>
</body>

</html>